/** \dir
 * Contains the source files for the \ref tree-gen tool.
 *
 * \file
 * Header file for \ref tree-gen.
 *
 * \page tree-gen tree-gen
 * tree-gen is a code generator that outputs all the repetitive stuff needed
 * for defining a proper tree structure in C++.
 *
 * Trees are described by *.tree files. Such a file consists of a number of
 * directives at the top and one or more tree node descriptions. Each tree node
 * gets its own C++ class, with a bunch of methods defined on it for traversal,
 * the visitor pattern, safe typecasting, cloning, and so on. It would be
 * extremely tedious and error prone to define all this stuff manually, hence
 * the generator.
 *
 * It is important to realize and perhaps not immediately obvious that the
 * recursive structure in a *.tree file represents C++ inheritance rather than
 * the actual tree structure. You may for instance encounter something like
 * this:
 *
 * ```
 * expression {
 *     addition {
 *         ...
 *     }
 *     subtraction {
 *         ...
 *     }
 * }
 * ```
 *
 * That doesn't mean an expression consists of an addition and a subtraction,
 * but rather that an addition is a type of expression, and subtraction is
 * another.
 *
 * \section base Base classes and primitives
 *
 * tree-gen trees consist of three kinds of objects: nodes, edges, and
 * primitives.
 *
 * The nodes are classes generated by tree-gen based on some base class. This is
 * typically tree::base::Base. The class inheritance tree of the node types is
 * used for "union" types, i.e. to allow some node in the tree to be one of a
 * number of types. For example, some node may want to have an expression child
 * node, which in practice would be for instance an addition node or a
 * subtraction node. At any level of this class hierarchy, nodes can be given
 * attributes to store data. These attributes are either edges or primitives.
 *
 * Edges define the relation between some parent node and some number of child
 * nodes. Six edge classes are defined, resulting in different relations between
 * the nodes.
 *
 *  - `tree::base::Maybe<T>`: the parent will own zero or one child node of
 *    (super)type T.
 *  - `tree::base::One<T>`: the parent will logically own exactly one child node
 *    of (super)type T.
 *  - `tree::base::Any<T>`: the parent will own zero or more child nodes of
 *    (super)type T.
 *  - `tree::base::Many<T>`: the parent will logically own one or more child
 *    node of (super)type T.
 *  - `tree::base::OptLink<T>`: the parent links to zero or one child node of
 *    (super)type T elsewhere in the tree.
 *  - `tree::base::Link<T>`: the parent logically links to exactly one child
 *    node of (super)type T elsewhere in the tree.
 *
 * The "logically" term used above alludes to the fact that One/Many/Link don't
 * necessarily need to have at least one child at all times. They may for
 * instance be empty during construction. But at least one child node is
 * required for the tree to be considered to be "complete". Furthermore,
 * completeness with respect to some root node requires that any Link or
 * non-null OptLink refers to a node that is actually reachable from that root
 * node.
 *
 * Maybe and One are based on std::shared_ptr<T>, Any and Many are based on
 * std::vector<One<T>>, and OptLink and Link are based on std::weak_ptr<T>, but
 * these types are abstracted away from the user almost entirely. Notably, all
 * exposed dereference operations are null- and range-checked, throwing
 * exceptions if there's a problem, rather than causing a segmentation fault
 * down the line.
 *
 * The namespace for the Base and edge classes can be set using the
 * `tree_namespace` directive in case you want to override them or add
 * functionality. Note that you can use "using One = tree::base::One;" etc. if
 * you only want to override part of the classes. If the tree_namespace
 * directive is not specified, the namespace that the node classes are generated
 * into will be used by default.
 *
 * Finally, primitives are used to store the actual data, forming the leaves of
 * the tree. They can generally be any externally-defined C++ type, although a
 * few template functions need to be defined and specialized for the types you
 * want to use. These are:
 *
 * ```
 * template <typename T>
 * T initialize() { ... }
 *
 * template <typename T>
 * void serialize(const T &obj, tree::cbor::MapWriter &map) { ... }
 *
 * template <typename T>
 * T deserialize(const tree::cbor::MapReader &map) { ... }
 * ```
 *
 * The initialize function is used to construct a primitive of type T in such a
 * way that it has a defined value. This is in contrast to the behavior of C's
 * own primitive types (int, bool, etc.), which are specified to be undefined
 * until assigned. This is avoided using this initialize function to prevent
 * confusion caused by undefined behavior. Typically, initialize() can be
 * implemented using just `return T{};` for the general case to defer to the
 * constructor for complex types, and then be specialized for the primitive
 * types that you want to use.
 *
 * The serialize and deserialize functions are optional. When given, logic is
 * generated to serialize and deserialize entire trees to and from a CBOR
 * representation.
 *
 * In addition to the type-safe primitives declared in the tree description
 * file, nodes can also be annotated using arbitrary types. Specifically, every
 * node can be annotated with zero or one annotation of every C++ type. So, any
 * struct or class you make can be attached to any node in the tree, regardless
 * of the tree specification. This is useful, for instance, to carry metadata,
 * such as line number or debugging information. When tree-gen is used to
 * generate some user-facing tree structure in a library, users of the library
 * can also use this to add their own data to a tree as they operate on it, to
 * prevent them from having to convert to their own data structure first.
 *
 * Note that the above requires RTTI to be enabled and supported by the
 * compiler, but there's really no good reason to disable that nowadays.
 *
 * \section nodes Defining node types
 *
 * Nodes have the following form in the tree file:
 *
 * ```
 * # [documentation for node class]
 * [snake_case_node_name] {
 *
 *     # [documentation for primitive]
 *     [snake_case_member_name]: [C++ namespace path];
 *
 *     # [documentation for edge/child node]
 *     [snake_case_member_name]: [Maybe|One|Any|Many|OptLink|Link]<[snake_case_node_name]>;
 *
 *     # [documentation for external edge/child node]
 *     [snake_case_member_name]: external [Maybe|One|Any|Many|OptLink|Link]<[C++ namespace path]>;
 *
 *     [zero or more specializations of this node; recursive structure]
 *
 * }
 * ```
 *
 * Nodes can have zero or more primitives, zero or more edges/child nodes, zero
 * or more *external* edges/child nodes, and zero or more specializations.
 *
 * The difference between normal edges and external edges is that the type for
 * a normal edge must resolve to another node in the same tree file, while an
 * external edge may use any C++ type name for the node class. That allows you
 * to refer to nodes defined in other tree files as well. Note however that the
 * generator expects external nodes to actually be node classes, such that it
 * can properly generate the debug dump indentation logic, among other things.
 *
 * Note that while node type names are specified in snake_case in the tree file,
 * the name will be converted to TitleCase for the generated class names to
 * follow decent C++ naming conventions. This is just because it's easier
 * to convert snake case to title case than vice versa, and the generator uses
 * both forms (title case for the class names, snake case for methods and
 * members).
 *
 * Note also the comments explicitly added to the example. Comments using a `#`
 * are interpreted as docstrings by the generator; they are copied into the
 * source code using javadoc-style comment blocks. This also means you can't
 * use `#`-"comments" everywhere, since they're actually a grammatical
 * construct. Therefore, tree-gen also supports `//` comments. These are
 * completely ignored by the parser.
 *
 * The order in which nodes are defined doesn't matter. This allows you to make
 * recursive tree structures, without having to worry about forward
 * declarations. The generator handles those. The order in which the attributes
 * of a node are defined does matter, though, as it's used for the order in
 * which the values can be passed to the node constructor; they are ordered
 * subclass to superclass, top to bottom.
 *
 * \section directive Directives
 *
 * The following directives exist. They should be placed at the top of the tree
 * file, before the first node. Their order doesn't matter, unless otherwise
 * specified. Note that most directives are required.
 *
 *  - `source`: used to specify documentation for the generated source file;
 *    any docstring above the directive is copied into the file as file-level
 *    doxygen documentation.
 *
 *  - `header`: used to specify documentation for the generated header file;
 *    any docstring above the directive is copied into the file as file-level
 *    doxygen documentation.
 *
 *  - `tree_namespace <namespace::path>`: the namespace that the
 *    Base and edge classes live in.
 *
 *  - `initialize_function <namespace::path::initialize>`: the name (including
 *    namespace path leading up to it) of the `T()` function used for getting
 *    the default value of any of the used primitive classes.
 *
 *  - `serdes_functions <namespace::path::serialize> <namespace::path::deserialize>`:
 *    optionally, the names (including namespace paths leading up to them) of
 *    the functions used to respectively serialize and deserialize primitive
 *    classes. If not specified, serialization functionality is disabled. Refer
 *    to the serialization section for more info.
 *
 *  - `location <namespace_path::SourceLocation>`: optionally, the name of the
 *    source location annotation class (including namespace path leading up to
 *    it). The debug dump will look for an annotation of this type on each node
 *    when doing a debug dump, and if it exists, uses it to add source
 *    information to the node, by streaming out a `#` followed by the stream
 *    overload for the class. The base class needs to be capable of annotations
 *    if you use this.
 *
 *  - `include "<path>"`: adds an `#include` statement to the top of the
 *    generated header file.
 *
 *  - `src_include "<path>"`: like `include`, but adds to the top of the
 *    generated C++ file only.
 *
 *  - `namespace <name>`: used to specify the namespace for the generated tree
 *    classes. As in C++, you need multiple of these to specify the full path.
 *    The docstring for the *first* annotation of this type that has a
 *    docstring in front is used to document the innermost namespace
 *    javadoc-style for Doxygen documentation.
 *
 * TODO:
 *
 *  - `python`: enables Python module generation and specifies the contents of
 *    the Python module `__doc__` value.
 *
 *  - `import ...`, `from ...`: adds Python import statements to the top of the
 *    generated module.
 *
 * \section apis Generated APIs
 *
 * The following methods are generated for each node class:
 *
 *  - a constructor with all members of the node in its signature as optional
 *    values, defaulting to the values returned by the initializer function.
 *
 *  - `bool is_complete() const`: returns whether the node its called on and
 *    any subtree rooted in that node is fully defined (no empty One, Many or
 *    Link, all array entries in Any/Many nonempty, and all Links and defined
 *    OptLinks reachable from the root node).
 *
 *  - `%NodeType type() const`: returns the type of this node, using the
 *    also-generated %NodeType enumeration.
 *
 *  - `One<Node> clone() const`: returns a shallow copy of this node.
 *
 *  - `One<Node> deep_clone() const` (TODO): returns a deep copy of this node.
 *
 *  - An equality and inequality operator. Note that this ignores equality of
 *    any annotations.
 *
 *  - `void visit(Visitor &visitor)`: implements the visitor pattern using the
 *    also-generated abstract Visitor/RecursiveVisitor classes. See below.
 *
 *  - `void dump(std::ostream &out=std::cout, int indent=0)`: does a debug
 *    dump of the node to the given stream with the given indentation level.
 *
 *  - `SomeNodeType *as_some_node_type()`: does the equivalent of a
 *    `dynamic_cast` to the given node type, returning `this` if the type is
 *    correct or `nullptr` if not.
 *
 * An implicit node class simply named `Node` is always generated, serving as
 * the base class for all other nodes. It is what derives from the `Base` class
 * defined in the namespace specified using tree_namespace.
 *
 * \subsection traversal Tree traversal
 *
 * Tree traversal is accomplished by starting at the root and working your way
 * down. The attributes specified in the tree file appear as public members of
 * the node classes. Maybe, One, OptLink, and Link can be dereferenced simply
 * using the * or -> operators; Any and Many use the [] indexation operator.
 * Note that these are all null- and range-checked, unlike the stdlib
 * equivalents.
 *
 * Tree traversal is complicated by the fact that you often don't know exactly
 * which type a class is. For example, an expression node may actually be a
 * subtraction or addition. For this, tree-gen supports a few different
 * patterns:
 *
 *  - *Visitor pattern.* You define a class inheriting from the generated
 *    `Visitor` or `RecursiveVisitor` classes. These abstract classes provide
 *    or require you to implement functions for each node type. The appropriate
 *    one then gets called when you pass an instance of your visitor class to
 *    the `visit()` method on a node. You must always override `visit_node()`,
 *    usually to throw a suitable exception in case an unexpected node is
 *    encountered. The default implementation for all the other node types
 *    differs between the two classes. For `Visitor`, the default implementation
 *    falls back to the next more generically typed function
 *    (`visit_subtraction()` falls back to `visit_expression()`,
 *    `visit_expression()` falls back to `visit_node()`). For
 *    `RecursiveVisitor`, the default implementation for non-leaf node types
 *    recursively calls `visit()` for all child nodes, thus recursively
 *    traversing the tree. For leaf nodes, both visitor classes have the same
 *    behavior.
 *
 *  - *Using the `as_*()` methods.* Given for instance an expression node, you
 *    might do
 *    ```
 *    if (auto addition = expression.as_addition()) {
 *      ...
 *    } else if (auto subtraction = expression.as_subtraction()) {
 *      ...
 *    } else {
 *      ...
 *    }
 *    ```
 *    Because a `nullptr` evaluates to false in C++, the blocks will only be
 *    executed if the cast succeeds. Be careful copypasting though; you can
 *    accidentally use the `addition` variable in the `subtraction` block if
 *    you'd want, but it's obviously null in that case. C++ scoping is weird.
 *
 *  - *Using a switch statement.* You might do
 *    ```
 *    switch (expression.type()) {
 *      case NodeType::Addition:
 *        ...
 *      case NodeType::Subtraction:
 *        ...
 *    }
 *    ```
 *    This doesn't handle the cast for you, but in cases where you only need to
 *    switch based on the type and don't need access to members of the nodes
 *    this is more descriptive than the if/else form.
 *
 * Just choose the method that makes the most sense within context.
 *
 * Note that tree-gen trees do *not* contain allow traversal back toward the
 * root of a tree. Supporting this would greatly complicate the internals and
 * the user-facing API, because then you wouldn't be able to just move nodes
 * around. It is therefore key that you design your trees and interfaces such
 * that this information is not needed. If this is somehow impossible, you'll
 * have to manage the links back up the tree manually using (Opt)Link edges.
 *
 * \subsection serdes Serialization and deserialization
 *
 * TODO: all functionality specified here is WIP
 *
 * Optionally, logic to serialize and deserialize trees can be generated in
 * addition to the APIs above. This makes use of the RFC7049 CBOR data format,
 * serving as a compromise between the readability of JSON and speed/simplicity
 * of the serialization and deserialization logic. Specifically, CBOR can be
 * losslessly converted to and from JSON using third-party tools if need be for
 * debugging (at least for as far as it's used here), but is itself a simple
 * binary format.
 *
 * The serialization and deserialization logic for the tree itself will be
 * generated, but to do that, tree-gen needs to know how to serialize and
 * deserialize primitive types. This is done through two templated functions
 * that the program must provide for all primitives in addition to the
 * initialization function:
 *
 * ```
 * template <typename T>
 * void serialize(const T &obj, tree::cbor::MapWriter &map) { ... }
 *
 * template <typename T>
 * T deserialize(const tree::cbor::MapReader &map) { ... }
 * ```
 *
 * The former must serialize `obj` by calling the various `append_*()` functions
 * on the given \ref tree::cbor::MapWriter "MapWriter" object. The latter must
 * perform the reverse operation. The namespace(s) and names of these functions
 * must be provided to tree-gen using the `serdes_functions` directive.
 *
 * When enabled, all generated classes will receive an additional constructor
 * taking a `const tree::cbor::MapReader &map` as argument for deserialization,
 * as well as a `void serialize(tree::cbor::MapWriter &map) const` method for
 * serialization.
 *
 * Each edge and each primitive receives its own object in the tree. Note that
 * Any and Many are internally represented as a vector of One edges; therefore,
 * Any/Many results in two nested edge objects. The data for nodes and their
 * annotations is stored along with the One/Maybe edges. The keys for the
 * objects are the following:
 *
 * ```
 * empty Maybe:
 *
 *     {
 *         "@T": "?",
 *         "@i": <sequence number>,
 *         "@t": null
 *     }
 *
 * filled Maybe:
 *
 *     {
 *         "@T": "?",
 *         "@i": <sequence number>,
 *         "@t": "<TitleCase node type name>",
 *         "<snake_case_attribute_name>": { <attribute data> },
 *         ...
 *         "{<annotation type>}": { <annotation data> },
 *         ...
 *     }
 *
 * One:
 *
 *     {
 *         "@T": "1",
 *         "@i": <sequence number>,
 *         "@t": "<TitleCase node type name>",
 *         "<snake_case_attribute_name>": { <attribute data> },
 *         ...
 *         "{<annotation type>}": { <annotation data> },
 *         ...
 *     }
 *
 * Any:
 *
 *     {
 *         "@T": "*",
 *         "@d": [
 *             <`One` object for each item>
 *         ]
 *     }
 *
 * Many:
 *
 *     {
 *         "@T": "+",
 *         "@d": [
 *             <`One` object for each item>
 *         ]
 *     }
 *
 * empty OptLink:
 *
 *     {
 *         "@T": "@",
 *         "@l": null
 *     }
 *
 * filled OptLink:
 *
 *     {
 *         "@T": "@",
 *         "@l": <sequence number of linked node>
 *     }
 *
 * Link:
 *
 *     {
 *         "@T": "$",
 *         "@l": <sequence number of linked node>
 *     }
 * ```
 *
 * The `@T` entry stores which type of edge an object is. This is not strictly
 * needed when deserializing as this information should be known by context;
 * instead, it is used as a validity check. The `@i` sequence numbers are unique
 * integers for all One/Maybe edges in the tree, which are used to recover the
 * (Opt)Link pointers through their `@l` key. The `@t` key is used to recover
 * subtype information, as the tree only knows the abstract supertype of a node
 * in general. These are, however, not necessarily globally unique; they only
 * need to distinguish between subclasses, and therefore just the TitleCase name
 * of the node type without C++ namespace is sufficient.
 *
 * Keys that start with a `{` and close with a `}` are used for annotations.
 * The string enclosed within the `{}` in the key is used to store the
 * annotation type. The identifier used can either be generated automatically by
 * C++ using `typeid(T).name()`, or can be specified manually to have more
 * control. Any annotation type that doesn't have a serialization and
 * deserialization function registered for it within
 * tree::annotatable::serdes_registry is silently ignored in either direction.
 *
 * All remaining keys map to the node attributes using their snake_case name.
 * The corresponding value is (recursively) one of the structures above for
 * edges, or a map containing user-specified key/value pairs for primitives,
 * serialized and deserialized using the functions specified by the
 * `serdes_functions` directive.
 *
 * The names of the keys are chosen such that, when ordered by ASCII value,
 * the order is as specified, and such that there can never be name conflicts.
 * The commonly used keys and values are short to minimize serialization and
 * deserialization overhead.
 *
 * \subsection python Python support
 *
 * TODO: all functionality specified here is WIP
 *
 * In addition to C++, tree-gen can also generate pure-Python objects to
 * represent the tree. As in C++, each node type becomes a class, and class
 * hierarchy is used similarly. The edge classes don't exist, however; instead,
 * their functionality is baked into the generated code to prevent an
 * unnecessary user-facing level of indirection during tree traversal that
 * cannot be hidden in Python.
 *
 * TODO: work out how primitives and external nodes would work
 *
 * The connection between the C++ and Python world is handled through CBOR
 * serialization and deserialization rather than providing Python wrappers
 * around the C++ objects. While this approach isn't as performant as the
 * alternative, it allows a much simpler and more Pythonic interface to be
 * exposed to the user, and is simpler to implement to begin with.
 *
 */

#ifndef _TREE_GEN_HPP_INCLUDED_
#define _TREE_GEN_HPP_INCLUDED_

#include <string>
#include <sstream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <map>
#include <memory>
#include <cctype>

/**
 * Namespace for the \ref tree-gen program.
 */
namespace tree_gen {

/**
 * Types of attributes that a node can have.
 */
enum AttributeType {

    /**
     * Zero or one nodes.
     */
    Maybe,

    /**
     * Exactly one node.
     */
    One,

    /**
     * Zero or more nodes.
     */
    Any,

    /**
     * One or more nodes.
     */
    Many,

    /**
     * Link to zero or one nodes elsewhere in the tree.
     */
    OptLink,

    /**
     * Link to exactly one node elsewhere in the tree.
     */
    Link,

    /**
     * Primitive type.
     */
    Prim,

};

struct NodeType;

/**
 * Represents a child node.
 */
struct ChildNode {

    /**
     * The type of child node.
     */
    AttributeType type;

    /**
     * The child node type, if any (depends on type).
     */
    std::shared_ptr<NodeType> node_type;

    /**
     * The primitive type name, if any (depends on type). If type is not
     * `Prim`, this is used for storing the node name before name resolution.
     */
    std::string prim_type;

    /**
     * Class member name.
     */
    std::string name;

    /**
     * Class member documentation.
     */
    std::string doc;

    /**
     * External node type. This is valid when `type` is Prim. If this is Prim
     * as well, then it's actually a primitive, otherwise it's a node from
     * another tree. This is kind of a kludge for having the dumper class
     * properly handle indentation here; that's the only place it's used.
     */
    AttributeType ext_type;
};

/**
 * Represents a type of AST node.
 */
struct NodeType {

    /**
     * Name in snake_case.
     */
    std::string snake_case_name;

    /**
     * Name in TitleCase.
     */
    std::string title_case_name;

    /**
     * Class documentation.
     */
    std::string doc;

    /**
     * The node type this is derived from, if any.
     */
    std::shared_ptr<NodeType> parent;

    /**
     * Node types derived from this one.
     */
    std::vector<std::weak_ptr<NodeType>> derived;

    /**
     * Child nodes.
     */
    std::vector<ChildNode> children;

    /**
     * Whether this node represents a recovered parse error.
     */
    bool is_error_marker;

    /**
     * Gathers all child nodes, including those in parent classes.
     */
    std::vector<ChildNode> all_children() {
        std::vector<ChildNode> children = this->children;
        if (parent) {
            auto from_parent = parent->all_children();
            children.insert(children.end(), from_parent.begin(), from_parent.end());
        }
        return children;
    }

};

/**
 * List of nodes.
 */
using Nodes = std::vector<std::shared_ptr<NodeType>>;

/**
 * Convenience class for constructing a node.
 */
class NodeBuilder {
public:

    /**
     * The node being constructed.
     */
    std::shared_ptr<NodeType> node;

    /**
     * Construct a node with the given snake_case name and class documentation.
     */
    NodeBuilder(const std::string &name, const std::string &doc="") {
        node = std::make_shared<NodeType>();
        node->snake_case_name = name;
        node->doc = doc;
        node->is_error_marker = false;

        // Generate title case name.
        auto snake_ss = std::stringstream(name);
        auto title_ss = std::ostringstream();
        std::string token;
        while (std::getline(snake_ss, token, '_')) {
            title_ss << (char)std::toupper(token[0]) << token.substr(1);
        }
        node->title_case_name = title_ss.str();
    }

    /**
     * Marks this node as deriving from the given node type.
     */
    NodeBuilder *derive_from(std::shared_ptr<NodeType> parent) {
        node->parent = parent;
        parent->derived.push_back(node);
        return this;
    }

    /**
     * Adds a child node. `type` should be one of the edge types.
     */
    NodeBuilder *with_child(
        AttributeType type,
        const std::string &node_name,
        const std::string &name,
        const std::string &doc = ""
    ) {
        auto child = ChildNode();
        child.type = type;
        child.prim_type = node_name;
        child.name = name;
        child.doc = doc;
        child.ext_type = type;
        node->children.push_back(std::move(child));
        return this;
    }

    /**
     * Adds a child primitive.
     */
    NodeBuilder *with_prim(
        const std::string &prim,
        const std::string &name,
        const std::string &doc = "",
        AttributeType type = Prim
    ) {
        auto child = ChildNode();
        child.type = Prim;
        switch (type) {
            case Maybe:   child.prim_type = "Maybe<" + prim + ">"; break;
            case One:     child.prim_type = "One<" + prim + ">"; break;
            case Any:     child.prim_type = "Any<" + prim + ">"; break;
            case Many:    child.prim_type = "Many<" + prim + ">"; break;
            case OptLink: child.prim_type = "OptLink<" + prim + ">"; break;
            case Link:    child.prim_type = "Link<" + prim + ">"; break;
            default:      child.prim_type = prim; break;
        }
        child.name = name;
        child.doc = doc;
        child.ext_type = type;
        node->children.push_back(std::move(child));
        return this;
    }

    /**
     * Indicate that this node marks a recovered parse error.
     */
    NodeBuilder *mark_error() {
        node->is_error_marker = true;
        return this;
    }

};

/**
 * Struct containing everything needed for a complete specification.
 */
class Specification {
private:

    /**
     * The node builders.
     */
    std::map<std::string, std::shared_ptr<NodeBuilder>> builders;

public:

    /**
     * Source file documentation.
     */
    std::string source_doc;

    /**
     * Header file documentation.
     */
    std::string header_doc;

    /**
     * The include statements to stick at the top of the header file.
     */
    std::vector<std::string> includes;

    /**
     * The include statements to stick at the top of the source file.
     */
    std::vector<std::string> src_includes;

    /**
     * Namespace documentation.
     */
    std::string namespace_doc;

    /**
     * The C++ namespaces to use.
     */
    std::vector<std::string> namespaces;

    /**
     * The namespace to take the tree base types from.
     */
    std::string tree_namespace;

    /**
     * The initialization function to use for default values of members.
     */
    std::string initialize_function;

    /**
     * The serialization function to use when serializing primitives. If empty,
     * no serdes logic should be generated.
     */
    std::string serialize_fn;

    /**
     * The serialization function to use when deserializing primitives.
     */
    std::string deserialize_fn;

    /**
     * Annotation object used for source location info, or empty if source
     * locations are not used or are not to be generated (applies to the dumper
     * only).
     */
    std::string source_location;

    /**
     * All the nodes.
     */
    Nodes nodes;

    /**
     * Sets the source file documentation.
     */
    void set_source_doc(const std::string &doc) {
        source_doc = doc;
    }

    /**
     * Sets the header file documentation.
     */
    void set_header_doc(const std::string &doc) {
        header_doc = doc;
    }

    /**
     * Sets the tree namespace.
     */
    void set_tree_namespace(const std::string &name_space) {
        if (!tree_namespace.empty()) {
            throw std::runtime_error("duplicate tree namespace declaration");
        }
        tree_namespace = name_space;
    }

    /**
     * Sets the initialization function.
     */
    void set_initialize_function(const std::string &init_fn) {
        if (!initialize_function.empty()) {
            throw std::runtime_error("duplicate initialization function declaration");
        }
        initialize_function = init_fn;
    }

    /**
     * Sets the serialization/deserialization functions.
     */
    void set_serdes_functions(const std::string &ser_fn, const std::string &des_fn) {
        if (!serialize_fn.empty()) {
            throw std::runtime_error("duplicate serialize/deserialize function declaration");
        }
        serialize_fn = ser_fn;
        deserialize_fn = des_fn;
    }

    /**
     * Sets the source location object.
     */
    void set_source_location(const std::string &ident) {
        if (!source_location.empty()) {
            throw std::runtime_error("duplicate source location object declaration");
        }
        source_location = ident;
    }

    /**
     * Adds an include statement to the header file.
     */
    void add_include(const std::string &include) {
        includes.push_back(include);
    }

    /**
     * Adds an include statement to the source file.
     */
    void add_src_include(const std::string &include) {
        src_includes.push_back(include);
    }

    /**
     * Adds a namespace level.
     */
    void add_namespace(const std::string &name_space, const std::string &doc = "") {
        namespaces.push_back(name_space);
        if (!doc.empty()) {
            namespace_doc = doc;
        }
    }

    /**
     * Adds the given node.
     */
    void add_node(std::shared_ptr<NodeBuilder> &node_builder) {
        auto name = node_builder->node->snake_case_name;
        if (builders.count(name)) {
            throw std::runtime_error("duplicate node name " + name);
        }
        builders.insert(std::make_pair(name, node_builder));
    }

    /**
     * Checks for errors, resolves node names, and builds the nodes vector.
     */
    void build() {
        if (initialize_function.empty()) {
            throw std::runtime_error("initialization function not specified");
        }
        for (auto &it : builders) {
            for (auto &child : it.second->node->children) {
                if (child.type != Prim) {
                    auto name = child.prim_type;
                    child.prim_type = "";
                    auto nb_it = builders.find(name);
                    if (nb_it == builders.end()) {
                        throw std::runtime_error("use of undefined node " + name);
                    }
                    child.node_type = nb_it->second->node;
                }
            }
            nodes.push_back(it.second->node);
        }
    }

};

} // namespace tree_gen

#endif
